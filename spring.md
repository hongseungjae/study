## 스프링 프레임워크는 객체지향프로그래밍의 다양한 철학을 포함하고 있습니다. (IoC, DI, 각종 패턴 등) 이 스프링 프레임워크를 간단하게 요약해서 설명하시오. 
* 내 대답 : DI , aop, psa

DI 의존성 주입
의존성이 줄어든다. (변경에 덜 취약해진다.)
모의 객체를 주입할 수 있기 때문에 단위 테스트가 쉬워진다.

aop 관점지향프로그래밍

psa 서비스추상화(트랜잭셔널)


객체 생성 및 관리를 스프링 컨테이너에 위임하여 개발자가 객체 생성에 집중하지 않고도 애플리케이션을 개발할 수 있도록 합니다. DI는 의존성 주입을 통해 객체 간 결합도를 낮추고, 유연한 애플리케이션 개발을 지원합니다.

핵심 비즈니스 로직과 관련 없는 부가적인 기능들을 분리하여 개발할 수 있도록 지원하는 프로그래밍 기법입니다.

AOP에서는 관심사 (Concern) 를 모듈화하여, 어떤 메소드가 실행될 때 해당 메소드의 전, 후에 수행될 코드를 미리 정의해놓을 수 있습니다. 이러한 모듈화는 코드 중복을 줄이고 유지보수성을 높일 수 있습니다. 대표적인 AOP 라이브러리로는 스프링 AOP, AspectJ 등이 있습니다.

PSA (Portable Service Abstraction)는 스프링이 제공하는 인터페이스 기반의 추상화 기술입니다. PSA를 사용하면 각종 기술의 구현체를 교체하더라도 애플리케이션 코드가 변경되지 않도록 지원합니다.

PSA는 스프링이 제공하는 다양한 모듈에서 활용되며, 대표적으로는 스프링의 데이터 액세스 계층 기술 (JDBC, JPA, MongoDB 등) 의 추상화 계층이 있습니다. PSA를 사용하면, 각종 기술을 유연하게 전환할 수 있으며, 코드의 가독성과 유지보수성을 높일 수 있습니다.

## 스프링 프레임워크에서 요청부터의 응답까지의 처리 흐름을 간단하게 요약해서 설명하시오.
스프링 맨처음 떠있는 포트로 요청이 오면 필터를 거치게 되고, 디스패처서블릿이라는 서블릿으로 맨처음 받게되고 거기에 매핑이 맞는 컨트롤러로 연결해줍니다.

스프링 프레임워크에서의 요청 처리 과정은 다음과 같습니다:

클라이언트가 요청을 보내면, DispatcherServlet이 이를 받아들입니다.
DispatcherServlet은 요청을 처리하기 위해 HandlerMapping에게 적절한 핸들러(컨트롤러)를 찾아달라고 요청합니다.
HandlerMapping은 요청 URL에 해당하는 핸들러(컨트롤러)를 찾아 반환합니다.
DispatcherServlet은 해당 핸들러(컨트롤러)를 실행합니다.
핸들러(컨트롤러)는 요청을 처리하고, ModelAndView 객체를 반환합니다.
DispatcherServlet은 핸들러(컨트롤러)가 반환한 ModelAndView 객체를 ViewResolver에게 전달하여, 적절한 뷰를 찾아 반환하도록 요청합니다.
ViewResolver는 ModelAndView 객체에 지정된 뷰 이름에 해당하는 뷰를 찾아 반환합니다.
DispatcherServlet은 뷰를 실행하여 응답을 생성합니다.
생성된 응답은 클라이언트에게 반환됩니다.
이러한 과정은 스프링의 MVC 패턴에서 적용되며, 스프링이 제공하는 다양한 기능 (AOP, PSA, 보안 등)이 추가로 적용될 수 있습니다.


## 멀티 쓰레드 환경에서 Thread-Safe 하기위해 할 수 있는 것은 무엇이 있는지 설명하시오. (스프링 프레임워크 기준)
불변, 싱크로나이즈드
빈 스코프 설정

빈 스코프는 빈이 생성되고 소멸되는 범위를 결정합니다. 스프링에서는 다양한 빈 스코프를 제공하며, 이를 통해 적절한 스코프를 선택하여 Thread-Safe한 빈을 생성할 수 있습니다. 예를 들어, Request 스코프는 각각의 HTTP 요청마다 새로운 빈 객체를 생성하며, Session 스코프는 각각의 세션마다 새로운 빈 객체를 생성합니다.
Synchronized 키워드 사용

Synchronized 키워드를 이용하여 공유 자원에 대한 접근을 동기화하여 Thread-Safe하게 만들 수 있습니다. 스프링에서는 메소드나 블록에 Synchronized 키워드를 사용할 수 있습니다.
ThreadLocal 사용

ThreadLocal을 이용하여 각 쓰레드마다 독립적인 값을 저장하여 Thread-Safe한 코드를 작성할 수 있습니다. 예를 들어, 스프링의 TransactionSynchronizationManager는 ThreadLocal을 이용하여 각 쓰레드마다 트랜잭션 정보를 저장합니다.
Immutable 객체 사용

Immutable 객체는 객체가 생성된 이후에는 내부 상태가 변경될 수 없는 객체를 말합니다. 이러한 Immutable 객체는 공유 자원으로 사용될 때 Thread-Safe하게 동작합니다.
ConcurrentHashMap 사용

ConcurrentHashMap은 스레드에 안전한 해시 맵입니다. 동시에 여러 스레드에서 접근하더라도 안전하게 동작하며, 병렬 처리를 지원합니다. 스프링에서는 ConcurrentHashMap을 많이 사용합니다.

## @Transactional 어노테이션에 대해 설명하고, 속성에 대해 아는대로 설명하시오.
프로파게이션, 전파범위
propagation (전파 옵션)

트랜잭션 전파 옵션을 설정합니다. 다른 트랜잭션이 이미 실행 중인 경우 어떻게 처리할지를 결정하는 옵션입니다. REQUIRED, REQUIRES_NEW 등이 있습니다.
isolation (격리 옵션)

트랜잭션 격리 수준을 설정합니다. 트랜잭션 실행 동안 다른 트랜잭션의 영향을 어느 정도 받을지를 결정하는 옵션입니다. READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE 등이 있습니다.
readOnly

트랜잭션을 읽기 전용으로 설정합니다. 읽기 전용으로 설정할 경우 커밋이나 롤백을 수행하지 않으며, 트랜잭션 리소스를 최적화할 수 있습니다.
timeout

트랜잭션 타임아웃을 설정합니다. 트랜잭션이 일정 시간 이내에 완료되지 않을 경우 롤백됩니다.
rollbackFor

롤백 대상 예외를 설정합니다. 특정 예외가 발생할 경우 트랜잭션을 롤백합니다.

## Transaction Propagation이란 무엇이고, 사용례에 대해서 설명하시오.
* 내 대답 : 트랜잭션 전파 범위로, 트랜잭션과 다른 트랜잭션의 침범 범위? 라고 생각합니다. 만약에 A라는 트랜잭션이 시작됐을 때, B트랜잭션이 시작되면, 기존에 진행되고 있는 트랜잭션과 합쳐질건지, 아니면 다른 트랜잭션으로 동작할 건지, 이런것들을 말합니다.

## 빈 스코프에서 싱글톤과 프로토타입 스코프의 차이에 대해 설명하시오.
* 내 대답 : 빈 스코프에서 싱글톤은 일단 빈들은 한번 생성 후 컨테이너에서 그 생명 주기라 관리하고 유지시켜주며, 프로토타입은 일시적으로 잠깐 생겼다가 없어지는 그런것으로 알고 있습니다.

빈 스코프는 스프링 프레임워크에서 빈 객체가 생성되고 유지되는 범위를 의미합니다. 스프링 프레임워크에서는 다양한 빈 스코프를 제공하는데, 그 중 가장 일반적으로 사용되는 것이 싱글톤(Singleton) 스코프와 프로토타입(Prototype) 스코프입니다.

싱글톤 스코프 : 스프링 컨테이너에서 생성된 빈 객체는 디폴트로 싱글톤 스코프입니다. 이 스코프에서 생성된 빈 객체는 애플리케이션 전역에서 하나의 객체만 생성되어 공유됩니다. 이렇게 하나의 객체를 공유하므로서 메모리 사용량을 줄일 수 있고, 객체 생성에 대한 오버헤드도 감소시킬 수 있습니다. 하지만, 멀티스레드 환경에서 동시에 객체에 접근할 때 동기화 문제가 발생할 수 있습니다.

프로토타입 스코프 : 프로토타입 스코프에서 생성된 빈 객체는 매번 새로운 인스턴스가 생성됩니다. 이 스코프에서 생성된 빈 객체는 각기 다른 인스턴스이므로, 각각 독립적으로 사용됩니다. 이렇게 매번 새로운 인스턴스를 생성하므로서 객체 간의 의존성 문제를 해결할 수 있습니다. 하지만, 객체 생성에 대한 오버헤드가 증가하고, 메모리 사용량도 증가합니다.

빈 스코프는 빈 객체의 생성과 소멸 시점을 제어할 수 있는 중요한 기능입니다. 빈 객체의 스코프를 설정하여 애플리케이션의 요구사항에 맞게 최적의 성능과 안정성을 제공할 수 있습니다.

## 스프링에서의 싱글톤 패턴과 디자인패턴의 싱글톤 패턴의 차이점
* 디자인패턴의 싱글톤은 일단 좀 이슈가 있는걸로 알고 있습니다. 싱글톤 패턴은 일단 인스턴스만 한개만 만들어져서 계속사용할 수 있는 장점이 있는데, 이게 만약 동시에 요청이 와서 인스턴스가 두개 되버리는 이런 문제점들이 있는?,, 근데 스프링에서는 이걸 해결했다.

디자인 패턴의 싱글톤 패턴은 객체를 딱 하나만 생성하고, 어디서든지 그 객체를 사용할 수 있도록 합니다. 이 패턴은 클래스 내부에 정적 변수로 인스턴스를 생성하고, 생성자를 private으로 선언하여 객체를 생성하는 것을 방지합니다. 이러한 방식으로 객체를 생성하면, 전역적으로 접근할 수 있는 유일한 객체를 생성할 수 있으므로, 일반적으로 객체 생성에 대한 오버헤드를 줄이고, 객체 간의 의존성 문제를 해결할 수 있습니다.

반면에 스프링에서의 싱글톤 패턴은 애플리케이션 전체에서 공유할 수 있는 하나의 객체를 생성하고, 스프링 컨테이너에서 해당 객체를 관리합니다. 스프링에서 빈 객체를 생성할 때, 기본적으로는 싱글톤 스코프로 생성됩니다. 이는 스프링 컨테이너가 한 번 생성한 빈 객체를 캐싱하고, 이후에 동일한 요청이 들어올 때마다 캐시된 객체를 반환하기 때문입니다. 따라서 스프링에서의 싱글톤 패턴은 객체 생성 및 관리에 대한 부담을 줄이면서도, 객체 간의 의존성 문제를 해결할 수 있습니다.


따라서, 스프링에서의 싱글톤 패턴과 디자인 패턴의 싱글톤 패턴은 목적과 사용 방법에서 차이가 있습니다. 스프링에서는 싱글톤 패턴을 사용하여 객체를 생성하고, 스프링 컨테이너에서 해당 객체를 관리하여 객체 생성 및 관리에 대한 부담을 줄이면서도, 객체 간의 의존성 문제를 해결할 수 있습니다.

## 무상태성에 대해 설명하시오.
* 

## 스프링 프레임워크에서 싱글톤 패턴을 언제 사용하는지에 대해서 설명하시오.
* 빈들을 만들때 사용합니다.
스프링 프레임워크에서 싱글톤 패턴은 기본적으로 빈(Bean) 스코프로 사용됩니다. 스프링에서 빈 스코프란, 빈 객체(Bean Object)가 생성되어 어플리케이션 컨텍스트에서 관리되는 범위(scope)를 의미합니다.

싱글톤 스코프는 하나의 빈 객체가 전역적으로 공유되어 사용됩니다. 이는 메모리 사용량을 줄이고, 빈 객체 생성에 따른 오버헤드를 줄여줌으로써 어플리케이션의 성능을 향상시킬 수 있습니다.

## 필터에 대해 설명하시오.
* 필터는 http 요청이 들어오고 이게 디스패처 서블릿으로 가기전에 일단 이 필터를 거치게 됩니다. 그래서 이 요청 내용이나 응답을 수정하거나 할 수 있습니다.

필터(Filter)는 서블릿(Servlet)의 인터페이스를 구현하여 HTTP 요청과 응답에 대한 처리를 수행하는 기능입니다. 필터는 클라이언트와 서버 간의 통신에서 요청(request)과 응답(response)을 중간에 가로채어 필요한 작업을 처리하거나 변형할 수 있습니다.

인증(Authentication)
권한 부여(Authorization)
요청 데이터 압축
요청 데이터 복호화
응답 데이터 압축
응답 데이터 복호화
요청 및 응답 데이터 로깅
캐시 제어

서는 필터를 통해 선처리(pre-processing)와 후처리(post-processing)를 수행할 수 있습니다. 선처리는 클라이언트의 요청을 처리하기 전에 필터에서 처리되는 작업을 의미하며, 후처리는 클라이언트의 요청에 대한 응답을 처리한 후 필터에서 처리되는 작업을 의미합니다. 

## 인터셉터에 대해 설명하시오.
* 인터셉터는 디스패처서블릿에서 컨트롤러 분기가 될 때, 거치게 됩니다. 
스프링 프레임워크에서 컨트롤러(Controller)와 뷰(View) 사이에서 요청(request)과 응답(response)을 가로채서 처리하는 역할을 합니다.


## 인터셉터를 실무에서 어떤 용도로 커스터마이징해서 써봤는지 설명하시오.
* 로그인 과정이나 cors 를 추가해봤다.

## 필터와 인터셉터와 어떤 차이가 있는지 설명하시오. 
필터와 인터셉터는 모두 웹 애플리케이션에서 요청을 가로채고 처리하는 기능을 수행하지만, 몇 가지 차이점이 있습니다.

실행 위치:
필터는 서블릿 컨테이너에서 해당 URL로 들어오는 요청을 처리하기 전에 실행됩니다. 반면, 인터셉터는 스프링 MVC에서 해당 컨트롤러로 요청이 전달되기 전 또는 후에 실행됩니다.

객체 타입:
필터는 서블릿 필터 인터페이스를 구현한 객체입니다. 인터셉터는 핸들러 인터셉터 인터페이스를 구현한 객체입니다.

적용 범위:
필터는 모든 URL에 대해 적용됩니다. 반면, 인터셉터는 특정 URL 패턴 또는 특정 핸들러에 대해서만 적용됩니다.

기능:
필터는 요청과 응답의 헤더 정보를 변경하는 데 주로 사용됩니다. 인터셉터는 요청 처리 전/후의 추가 작업을 수행하는 데 주로 사용됩니다. 예를 들어, 로그인 인증을 처리하거나, 권한 체크를 수행하거나, 캐싱을 구현하는 등의 작업을 수행할 수 있습니다.

따라서 필터는 서블릿 컨테이너 레벨에서 동작하며, 스프링과 관련 없는 기능을 수행하는 데 주로 사용됩니다. 반면, 인터셉터는 스프링 프레임워크에서 제공하는 기능으로, 컨트롤러 전후의 로직을 처리하거나 요청/응답을 가로채서 추가 작업을 수행하는 데 사용됩니다.


## 순환참조를 해결하기 위해서는 어떻게 해야하는지 설명하시오. 
* 이벤트를 활용해 순환참조를 끊을 수 있다. 예를 들어서 서비스계층끼리 순환참조가 있다고 가정했을 때, 다른 서비스에 의존하는것이 아닌 메서드 호출 됐을 때 이벤트를 발생시키고, 이 이벤트에게 처리를 맡기게 해서 순환참조를 끊은 개발을 한적이 있습니다.

순환 참조가 발생하는 빈에서 Setter Injection 대신 생성자 주입을 사용하는 방법입니다. 이 방법을 사용하면 해당 빈을 생성할 때 필요한 의존성을 생성자에서 모두 주입받기 때문에, 순환 참조가 발생하지 않습니다.

## ThreadLocal에 대해 설명하시오.
* 쓰레드에 저장할 수 있는 어떤 공간을 말합니다.

## ThreadLocal을 실무에서 써본 경험이 존재하는지 혹은 존재하지 않더라도 어떤 상황에서 이를 사용할 수 있을지 설명하시오.
* 써본 경험이 없는데, 쓰레드에서 커넥션을 얻을때 , 그 커넥션의 id값 이런것을 기록하기 위해서 ThreadLocal에 기록한다고 알고 있습니다.

## AOP 개념들(Aspect, JoinPoint, Advice, Target)에 대해서 설명하시오.
* aop는 일단 기존 핵심로직에서 부가적인 로직 수행을 위해 하기위한걸로, 
* joinpoint는 어느 조건으로 걸릴건지, Advice는 어떤 동작을 수행하는지, target 어떤 대상에게 하는지

## AOP Weaving 방식(LTW, RTW, CTW)에 대해서 설명하시오.
모름

## 스프링은 어떤 DI 방식들이 존재하고 평소에 어떤 방식으로 주입을 하는지 설명하시오.
* 수동주입, 자동주입이 있을 것 같습니다. 
* 수동주입은 빈을 직접 지정하는것이고, 자동주입은 Autowired 이런 애노테이션을 통해서 자동으로 빈을 찾아서 넣어줍니다.
* Autowired

스프링에서는 생성자 주입 방식을 권장합니다. 생성자 주입 방식은 불변성을 보장하고, 스프링의 @Autowired 어노테이션을 사용해 코드가 간결해집니다. 하지만, 선택적인 의존성이 필요한 경우에는 세터 주입 방식이나 필드 주입 방식을 사용할 수도 있습니다

## 왜 생성자 주입 방식을 사용하는지 설명하시오.
* null을 방지할수있고, 단위테스트 하기 쉽다.

## ApplicationContextAware가 무엇인지 설명하시오.
ApplicationContextAware는 Spring 프레임워크에서 제공하는 인터페이스 중 하나로, Bean이 ApplicationContext로부터 DI를 받을 수 있게 해줍니다.

이 인터페이스를 구현한 Bean은 ApplicationContext에 의존하는데, 이를 통해 다른 Bean들을 가져와서 사용할 수 있습니다. 이를 통해 ApplicationContext에서 제공하는 다양한 기능들을 활용할 수 있습니다.

예를 들어, ApplicationContextAware를 구현한 클래스에서는 ApplicationContext의 getBean() 메소드를 호출하여 다른 Bean을 가져와 사용할 수 있습니다. 이를 통해 DI를 자동으로 처리하지 않고, 필요한 Bean을 직접 가져와 사용할 수 있습니다.

ApplicationContextAware를 구현하는 방법은 두 가지가 있습니다. 첫 번째는 ApplicationContextAware 인터페이스를 구현하고, setApplicationContext() 메소드를 오버라이딩하는 것입니다. 두 번째는 Spring 2.5 이후부터는 @Autowired 어노테이션을 이용하여 구현할 수 있습니다.

## Spring 프레임워크의 모듈화에 대해서 설명하시오. 
Spring 프레임워크는 기능별로 여러 모듈로 나누어져 있습니다. 이러한 모듈화 구조는 유연하고 모듈 간 의존성을 줄이며, 필요한 모듈만 선택적으로 사용할 수 있도록 합니다.

Spring 프레임워크의 주요 모듈로는 다음과 같은 것들이 있습니다.

Core Container: 스프링의 핵심 기능인 DI(Dependency Injection)와 IoC(Inversion of Control)를 제공합니다. spring-core, spring-beans, spring-context, spring-expression 모듈로 구성됩니다.

AOP(Aspect-Oriented Programming): OOP(Object-Oriented Programming)을 보완하는 개념으로, 애플리케이션의 다양한 모듈에서 공통으로 사용되는 기능들을 분리해서 관리하고, 재사용성을 높여줍니다. spring-aop, spring-aspects 모듈로 구성됩니다.

Data Access/Integration: 데이터베이스와의 연동을 위한 기능을 제공합니다. spring-jdbc, spring-tx, spring-orm, spring-oxm 모듈로 구성됩니다.

Web: 웹 애플리케이션 개발을 위한 기능을 제공합니다. spring-web, spring-webmvc, spring-websocket, spring-webflux 모듈로 구성됩니다.

Test: 스프링 애플리케이션의 테스트를 위한 기능을 제공합니다. spring-test 모듈로 구성됩니다.

이와 같이 Spring 프레임워크는 각각의 기능에 따라 모듈화가 되어 있어서 필요한 기능만 선택적으로 사용할 수 있습니다. 또한, 모듈 간의 의존성도 최소화되어 있기 때문에, 애플리케이션을 개발할 때 필요한 모듈만 추가하여 사용할 수 있습니다.


## Spring Boot를 사용할 때 설정이 자동으로 주입이 되는데 이 방식에 대해서 자세하게 설명하시오. 
* Config 이런애노테이션 이었던거?, 잘기억은 안나지만 어떤 어노테이션이 존재하여서 그걸로인해 자동주입되는걸로 알고잇음

Spring Boot에서는 자동 설정 기능을 하는 어노테이션이 @EnableAutoConfiguration 입니다. 이 어노테이션은 Spring Boot의 자동 설정 메커니즘을 활성화하고, 애플리케이션 클래스에서 @Configuration 어노테이션이 붙은 클래스를 찾아서 자동 설정을 수행합니다.

## 아래의 코드를 보고 어떤 식으로 프로그램이 동작할 것 같은지 설명하시오.


