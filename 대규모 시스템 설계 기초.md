### 1 장 사용자 수에 따른 규모 확장
* 데이터베이스 다중화 시
  - 보통 master-slave 관계 설정을 하고 원본은 master, 사본은 slave에
  - slave에서는 읽기 연산만
  - 부하분산, 가용성(하나 죽어도, 다른 서버로 계속 서비스 가능)

* 캐시 사용 시 유의점
  - 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼만 함
  - 어떻게 만료되는지? 짧으면 db에 자주접근, 길면 원본과 차이날 가능성
  - 일관성은? 만일 저장소의 원본을 갱신하는 단일 트랜잭션으로 처리되지 않으면 깨질수도, 시스템 확장시에도 일관성 어떻게 유지?
  - 캐시 서버 한 대만 둘 경우 단일 장애 지점됨 -> 캐시 서버 분산
  - 캐시 메모리
  - 캐시 교체 알고리즘, LRU, LFU, FIFO, LRU 많이 쓰임

* CDN
  - 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크, 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있음
  - 고려사항 -> CDN 비용, 만료 시한, CDN 서버 죽었을 시 대처 방안, 콘텐츠 무효화 방법(만료되지 않은 콘텐츠라도 CDN에서 제거방법) -> 콘텐츠의 새로운 버전을 URL뒤에 명시, CDN 서비스가 제공해주는 API이용

* 웹 계층을 수평적으로 확장하는 방법
  - 웹계층을 무상태로, 사용자 세션 데이터와 같은 것을 제거, 이를 위해 상태 정보를 RDB나 NoSQL 같은 지속성 저장소에 보관하면됨

* 상태 정보의 의존적인 웹 계층은 서버가 늘어나면 대응하기위해 고정 세션을 사용해야됨
  - 로드밸런서의 부담을 줌, 뒷단 서버를 추가하거나 제거하기도 까다로움, 서버의 장애 처리도 복잡해짐

* 메시지 큐
  - 메시지의 무손실(메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트
  - 생산자 또는 발행자(producer/publisher))라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행 -> 소비자 혹은 구독자(consumer/subscriber)라 불리는 서비스가 메시지를 받아 그에 맞는 동작 수행
  - 서비스, 서버간 결합이 느슨해져 규모 확정성이 좋음, 생산자는 소비자 프로세스가 다운되어도 발행하고 소비자도 생산자가 가용상태가 아니더라도 메시지 수신 가능
  - 메시지큐의 큐가 많이 쌓이면 소비자를 늘림, 아니면 큐가 거의 비어있으면, 소비자 작업 프로세의 수를 줄임 , 독립적으로 확장

* 데이터베이스의 규모확장
  - 수직적 확장
    - 스케일업, 고성능의 자원을 증설하는 방법
    - 하드웨어는 결국 한계가 있음
    - SPOF(Single Point of Failure)의 위험성
    - 비용이 많이듬

  - 수평적 확장
    - 샤딩, 샤드라고 부리는 작은 단위로 분할하는 기술
    - 모든 샤드는 같은 스키마, 중복되는 데이터는 없음
    - 샤딩키에 따라 어느 샤드에 저장할지 결정됨 -> 샤딩 키를 어떻게 정해야 하는지 포인트
    - 샤딩키를 정할 때 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요함
    - 문제점
    1. 데이터의 재 샤딩 : 샤드 간 데이터 분포가 균등하지 못하여 한쪽 샤드가 빨리 소진될때(샤드 소진), 샤드 키를 계산하는 함수를 변경하고 데이터 재배치해야됨
    2. 유명인사 문제 : 질의가 특정 샤드에 집중될 때, 분배해야됨
    3. 조인과 비정규화 : 여러 샤드 서버로 쪼개면, 여러 샤드에 걸친 데이터를 조인하기가 힘듬, 데이터베이스를 비정규화하거나 하나의 테이블에서 질의 될수있도록해야됨
  


* 락없을 때
  - 안정해시
  - 

* 시퀀스 문제점
