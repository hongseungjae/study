### 1 장 사용자 수에 따른 규모 확장
* 데이터베이스 다중화 시
  - 보통 master-slave 관계 설정을 하고 원본은 master, 사본은 slave에
  - slave에서는 읽기 연산만
  - 부하분산, 가용성(하나 죽어도, 다른 서버로 계속 서비스 가능)

* 캐시 사용 시 유의점
  - 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼만 함
  - 어떻게 만료되는지? 짧으면 db에 자주접근, 길면 원본과 차이날 가능성
  - 일관성은? 만일 저장소의 원본을 갱신하는 단일 트랜잭션으로 처리되지 않으면 깨질수도, 시스템 확장시에도 일관성 어떻게 유지?
  - 캐시 서버 한 대만 둘 경우 단일 장애 지점됨 -> 캐시 서버 분산
  - 캐시 메모리
  - 캐시 교체 알고리즘, LRU, LFU, FIFO, LRU 많이 쓰임

* CDN
  - 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크, 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있음
  - 고려사항 -> CDN 비용, 만료 시한, CDN 서버 죽었을 시 대처 방안, 콘텐츠 무효화 방법(만료되지 않은 콘텐츠라도 CDN에서 제거방법) -> 콘텐츠의 새로운 버전을 URL뒤에 명시, CDN 서비스가 제공해주는 API이용

* 웹 계층을 수평적으로 확장하는 방법
  - 웹계층을 무상태로, 사용자 세션 데이터와 같은 것을 제거, 이를 위해 상태 정보를 RDB나 NoSQL 같은 지속성 저장소에 보관하면됨

* 상태 정보의 의존적인 웹 계층은 서버가 늘어나면 대응하기위해 고정 세션을 사용해야됨
  - 로드밸런서의 부담을 줌, 뒷단 서버를 추가하거나 제거하기도 까다로움, 서버의 장애 처리도 복잡해짐

* 메시지 큐
  - 메시지의 무손실(메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트
  - 생산자 또는 발행자(producer/publisher))라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행 -> 소비자 혹은 구독자(consumer/subscriber)라 불리는 서비스가 메시지를 받아 그에 맞는 동작 수행
  - 서비스, 서버간 결합이 느슨해져 규모 확정성이 좋음, 생산자는 소비자 프로세스가 다운되어도 발행하고 소비자도 생산자가 가용상태가 아니더라도 메시지 수신 가능
  - 메시지큐의 큐가 많이 쌓이면 소비자를 늘림, 아니면 큐가 거의 비어있으면, 소비자 작업 프로세의 수를 줄임 , 독립적으로 확장

* 데이터베이스의 규모확장
  - 수직적 확장
    - 스케일업, 고성능의 자원을 증설하는 방법
    - 하드웨어는 결국 한계가 있음
    - SPOF(Single Point of Failure)의 위험성
    - 비용이 많이듬

  - 수평적 확장
    - 샤딩, 샤드라고 부리는 작은 단위로 분할하는 기술
    - 모든 샤드는 같은 스키마, 중복되는 데이터는 없음
    - 샤딩키에 따라 어느 샤드에 저장할지 결정됨 -> 샤딩 키를 어떻게 정해야 하는지 포인트
    - 샤딩키를 정할 때 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요함
    - 문제점
    1. 데이터의 재 샤딩 : 샤드 간 데이터 분포가 균등하지 못하여 한쪽 샤드가 빨리 소진될때(샤드 소진), 샤드 키를 계산하는 함수를 변경하고 데이터 재배치해야됨
    2. 유명인사 문제 : 질의가 특정 샤드에 집중될 때, 분배해야됨
    3. 조인과 비정규화 : 여러 샤드 서버로 쪼개면, 여러 샤드에 걸친 데이터를 조인하기가 힘듬, 데이터베이스를 비정규화하거나 하나의 테이블에서 질의 될수있도록해야됨
  
* 안정 해시
  - 해시를 모듈러연산에서 키를 찾아내는 방법은 풀의 크기가 고정되어 있을 때, 데이터 분포가 균등할 때 잘 동작
  - 그러나 서버가 추가되거나 기존 서버가 삭제 되면 문제, 모듈러연산 결과가 달라지기때문 -> 대규모 캐시 미스 발생 -> 안정해시는 이를 해결하기위함
  - 해시링을 만들어서 서버를 배치하고 그 위에 가까운 키를 해당 서버에 저장
  - 결과적으로 보다 데이터가 균등하고, 재배치되는 키의 수가 최소하ㅗ됨


* 일관성 유지
  - 버저닝과 벡터시계
  - 

* 분산 시스템에서 유일성이 보장되는 ID 만들기
  - 다중 마스터 복제
    - 데이터베이스이 auto_increment 활용, 1씩 증가가 아닌 각 K만큼 증가( 1 3 5, 2 4 6)
    - 여러 데이터 센터에 걸쳐 규모를 늘리기어려움
    - 서버를 추가하거나 삭제할 때 잘동작하기 어려움

  - UUID
    - 128비트짜리 수
    - 충돌확률 낮음, 단순함, 규모 확장 쉬움
    - 128비트로 길다, 시간순으로 정렬안됨, ID에 숫자 아닌 값이 포함될 수 있음

  - 티켓 서버
    - auto increment 기능을 갖춘 데이터베이스 서버를 두는 것, 중앙 집중형
    - SPOF(Single-Point-of_Failure)

  - 트위터 스노플레이크 접근법
    - 독창적인 ID생성 기법
    - ID의 구조를 여러 절로 분할하는 것(사인 비트, 타임스태프, 데이터센터 ID, 서버 ID, 일련번호)

* 채팅시스템
* 게시판 캐시
* 
