### 래퍼클래스란
기본 자료형을 참조형 자료형처럼 사용하기 위한 클래스이다.

래퍼클래스는 왜?

1. 먼저 null을 가질 수 있습니다
예를 들어서 필드를 기본자료형을 쓰면 기본 값을 세팅이 됩니다. 근데 이걸 0으로 값으로 의도한 것인지, 아니면 단순 값을 초기화안한건지 구분이 안될 수 있습니다.
예시로는 jpa 엔티티 pk값을 Long을 초기화전에 null을 대입해놓고 pk가 아직할당되지 않음을 나타낼수있음, 그러나 기본자료형은 X

래퍼클래스는 null을 가질수 있기때문에 이런 실수를 줄일 수 있습니다.

2. 그리고 참조자료형을 파라미터로 받는 것들이 있습니다.
기본형대신 참조형 쓰는 이유
1. 제네릭을 사용 -> 타입안정성때문에
2. 멀티쓰레딩환경에서 안전하게 사용하기 위해

예를 들어 컬렉션에 값을 추가할때 참조형으로 넣어줘야되어서 래퍼로 바꿔야 합니다. 이때 오토박싱이라는 기능이 동작해서
자동으로 기본자료형이 -> 참조자료형으로 바뀝니다.

3. 래퍼클래스는 또한 값을 가질수 있는데 예를 들어 int형의 맥스값인 Integer.MAX_VALUE이런 상수 값을 가지고 있어서 쉽게 가져올수있습니다.


기본자료형 -> 참조자료형 boxing
참조자료형 -> 기본자료형 unboxing
이런 autoboxing 으로 인해 안바꿔줘도됨

특징은
불변객체이고 -> 멀티쓰레딩에 안전

기본자료형의 장점은
1. 연산이 자주일어나는 곳에 쓰이면 래퍼클래스를 쓰는대신 오토박싱이 안일어나기때문에 성능에 조금유리

2. 또한 필드에 null이 필요없고, 기본값을 0으로 지정해줘도 되는곳

### 부동소수점이란
부동소수점이란


부동소수점은 실수를 표현할 때 소수점의 위치를 고정하지 않는 것을 말합니다

부동소수점에 쓰는 비트는 한정되어있기때문에 
반대인 고정소수점보다 훨씬 넓은 범위의 수를 표현할 수 있는 장점이 있다. 

하지만 그럼에도 실수를 이진법으로 계산하다보면 무한소수가 나올수 있습니다.
그래서 정확한 계산이 필요한 경우 라이브러리를 쓰는데 자바는 bigDecimal이라는 클래스를 사용합니다


컴퓨터는 1.1을 정확히  표현을 못함 float나 double을 써도 그 근사치를 표현할 뿐 왜?
-> 이진법으로 실수계산을 하면 무한소수가 나올수 있다.


실수를 이진법으로 바꾸는 방법
정수부분 따로 취하고, 소수점 부분은 2로 곱해서 1인 부분을 따로 기록, 계속하다보면 0으로 아니면 무한소수

음수 나타내는 방법
1. 1의 보수법은 모든 비트 반전  -> +0과 -0이 따로 존재하는 문제점
2. 2의 보수법은 1의보수법을 취한뒤 +1 -> 단 하나의 0

### 가비지 컬렉션이란
 Heap공간에서 더이상 참조(reference)되지 않는 메모리 공간을 수거한다. 

가비지컬렉션 방법
Mark and Sweep
Root Set에서 접근 가능한 객체들의 flag를 ‘in-use’로 마킹한다
모든 메모리 공간을 순회하며 flag 값이 ‘in-use’로 되어 있지 않은 객체들의 메모리를 해제한다.

### ascii코드가 무엇인가?
문자를 숫자로 대응되는 표로 만든것 1바이트로 2^8 = 256 이므로 0~255까지 표현가능하므로 256종류까지 만들수있는 캐릭터셋중 하나.

만들어놓는 이유 : 모양을 알고 보낼수 없고 0과 1이라는 신호만으로 보낼 수 있음.

1바이트 4바이트 이상 확장된게 유니코드 UTF-8


### 단축평가
&& 로 평가하게되면
앞에 것 보고 뒤에것을 평가를 안하기때문에 성능상 더 이점 -> 쇼트 서킷, 단축 평가
&로 하게되면 둘다 평가하게됨, 비트연산자임



### 상속은 언제 해야할까?
메서드 재사용의 목적은 아님
-> 상속 보다는 합성을 사용해야 합니다.
상속은 결합도가 증가하게 됩니다. 깊은 의존성이 맺어지기때문에 부모의 변경이되면 자식클래스도 변경될수있는 캡슐화가많이 깨지게 됩니다.

따라서 부모클래스의 필드를 가져오고 싶을때 사용할 수있습니다.

### 리스코프치환 원칙 : 하위타입의 객체를 전달해도 상위타입을 받는 메서드에도 잘 동작해야됨 -> 안하게되면 다형성이 의미가없음
instanceof 

### api란 Application Programming Interface)
두 애플리케이션이 서로 통신하는 방법을 정의


### toString 메서드 자동 호출하는 경우

System.out.println()에 인자로 객체를 넘길 때
String과 객체가 + 연산 할 때


### 
동일성 : 두 개의 객체가 완전히 같은 경우 (주소 값이 같음)
동등성 : 두 개의 객체가 같은 정보를 갖고 있는 경우를 의미



### hashcode와 equals
hahshcode :  객체의 주소값(int)을 이용하여 객체 고유의 해시코드

객체를 비교할 때는 equals를 오버라이딩을 해줘야됨, 아니면 주소값으로 비교를 해서 같은 값을 가져도 false로 나오게됨

또한 equals를 오버라이딩하면 hashcode도 오버라이딩해줘야 하는데
hash를 사용하는 컬렉션에 넣을 때 이 hashcode로 비교를 하게되기때문에,  같은 객체가 두번 저장될 수 있음


### 같은 hash 값을 가질 때 해결 방법
Open Addressing - > 다른 비어있는 버킷 찾아이동
Seperate Chaining -> 링크드리스트나 트리로 처리


### 예외를 직접 발생시켜주는 경우는 언제일까?
클라이언트 값이 유효한지 확인 -> 유효성 검사시에 예외를 던지는데 많이 쓰임.

자주 저지르는 실수 : null 또는 0을 던지기 -> 결과문에서 null값을 처리해야함. if문 사용으로 또 복잡해짐-> 불필요한 분기를 만듬

스레드를 처리할 수 없는 상황에 예외를 발생


### 스트링 관련하여
1. String에서 동일성 동등성의 관계를 따져야 할 때 가 언제인지?
스트링을 리터럴 형식으로 생성 시 constant pool이라는 곳에서 형성 되어 같은 주소값으로 가지게됨(성능이점, 스트링은 매우많이 쓰기때문), 그러나 일반 new 연산자로 만들게 될 경우 새로운 주소값을 할당됨
따라서 동일성비교가 아닌 동등성 비교를 해야됨 (값을 비교하기 위해서)

2. hashcode도 오버라이딩 이유
new 연산자로 만들게 되면 같은 값을 가져도 해시 코드가 달라 다른 객체로 인식하기때문 -> 해시 코드를 같은 값이 같은 값을 가질수 있게 오버라이딩


### 정규표현식이란
 문자열 안에 또다른 문자열을 찾기 위해 (특정 문자열 조합을 찾아내고 싶을때) 사용 


### reflection 이란?
클래스의 메타정보(클래스의 이름이나 내부의 메소드 명과 같은 부분.)를 이용해서 로직을 구성하여 사용할 수 있게 해주는 클래스


프로그램이 정상적으로 접근할 수 없는 영역에 접근할 수 있게 해줌
private라던가
메소드 하나하나 볼수 있음.

### 확장자를 붙여주는 이유
OS를 사용하고 있는 사용자에게 알려주는 것. (사람에게 도움)

확장자에 해당하는 프로그램이 없다고 하면 프로그램을 뭘로 열어야하는지 운영자가 모름.

hex에디터로 파일 안쪽에 시작하는 16진수(file signature)보고 무슨파일포맷인지 알수있음. -> 파일 시그니처 확인

### 멀티프로세스, 멀티플렉싱, 멀티쓰레드
멀티플렉싱 : 하나의프로세스에서 여러개 처리, select 함수 이용
모두 운영체제의 도움을 받아 콜백 함수로 이벤트처리를 통해 논 블로킹을 구현

### 병렬성 vs 동시성
병렬성은 있는작업과 없는 작업으로 나누어짐.
동시성이 좋다, 동시성이 떨어진다로 이야기함.

### 자바 8

1. 람다표현식 : 메소드를 하나의 식으로 표현한 것입니다.
기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높이는 데 그 목적이 있습니다.
쓰레드 예제 ->원래는 쓰레드 익명 클래스를 만들어서 run 오버라이딩해야되는 코드를 작성
이를 단순하게 표현ㅎ할수잇음

단 하나의 추상 메서드를 갖는 인터페이스를 함수형 인터페이스 -> Runnable 인터페이스
람다 표현식은 함수형 인터페이스를 간결하게 표현할 수 있다.

2. 스트림
컬렉션을 편리하게 처리할수있음
1. 병렬처리
2. 가독성 증가
3. 데이터 추상화

3. Interface default Method 도입
Interface 내부에서 default 메서드를 선언할 수 있다. 

4. Optional Class 도입
Optional을 이용하여 null을 다양하게 처리할 수 있음
1. null 방어 코드가 없어짐
null 이 나올경우 exception발생시키거나 값이 있을 경우 처리 아니면 exception


### volatile을 걸어줄 수 있습니다. (메모리에 직접 읽고 쓰게함) , 캐시가 아닌 가시성문제를 해결
그러나 원자성 문제를 해결못함
i++;
i의 값을 읽는다. (READ)
i에 1을 더한다. (MODIFY)
i의 값을 쓴다. (WRITE)

따라서 두 쓰레드가 공유 변수에 읽기/쓰기 를 실행할 때 synchronized 필요하고,
한 변수를 두고 오직 한 쓰레드만 이 변수에 읽기/쓰기 작업을 하고, 다른 쓰레드들은 읽기 작업만 하는 상황에서는 
volatile 선언이 유효합니다.

위에 상황일때 안걸면 캐시되어진 값을 안읽고 메모리값을 읽어가서 일관성이 안맞을수있음


### MIME은 Multipupose internet Mail Extensions의 약자로 
마임타입은 파일에 형식으로 받는쪽에서 어떤 방식으로 해석해야되는지 알려주는 것

### g1gc 이점

바둑판 같은 영역으로 나눠어져 있는데 gc과정중에서 Heap Memory 전체를 탐색하는 것이 아닌 영ㅉ역으로 나눠 탐색하고 영역 별로 gc를 합니다

### GET메서드가 왜 안전한 메서드여야 하는가?
즉 의도치않게 호출될 수 있는 경우가 많기때문임. 안전하지 않으면 예상치 못하게 호출했을 때 사이드이펙트가 생길수도 있음


### 301 Mover Permanently , 영구

- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.

### 308 Permanent Redirect , 영구

- 301과 기능은 같다

- 리다이렉트시 요청 메서드와 본문 유지(처음에 POST를 보내면 리다이렉트도 POST 유지)

### 302 Found, 일시

- PRG
- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다.


### 307 Temporary Redirect, 일시

- 302와 기능은 같다.

- 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안 된다.)

### 영구, 일시는 검색 엔진에 관점, 랭킹유지할것인지 변경되도 되는지



