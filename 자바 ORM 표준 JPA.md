* SQL매퍼 문제점
1. CRUD 코드의 반복
2. SQL의 의존적
    - 멤버 엔티티에 컬럼이 추가될경우 sql도 수정해야됨
    - 멤버 엔티티에 팀 엔티티를 추가할 경우 sql도 수정해야 null을 방지할 수 있음

3. 객체 구조를 테이블 구조에 저장하는 데는 한계가 있음 -> 패러다임 불일치
    - 상속
    - 참조 vs 외래키
    - 그래프탐색 자유로이 할 수 있는가 -> JPA는 지연로딩을 통해 해결
    - 비교 같은 로우를 select를 했을 때 == 동일성 비교를하면 false가 나옴 객체이기때문에 -> JPA는 같은 트랜잭션일 때 같은 객체 보장

* JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준
* ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑한다는 뜻, ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해

* JPA 장점
  1. 생산성
  2. 유지보수
  3. 패러다임의 불일치 해결
  4. 성능 : 같은 트랜잭션에 두 번 조회하면 한번만 db에 접근
  5. 데이터 접근 추상화와 벤더독립성 : 예를 들어 JPA Dialect를 사용하기때문에 각 db마다 dialect를 바꿔서 넣어주면됨
 
* 엔티티 매니저 팩토리는 엔티티 매니저를 제공해줌, 만드는 비용이 크기때문에 한 개만 만들어서 애플리케이션 전체에 공유, 여러 스레드가 동시에 접근해도 안전함
* 엔티티 매니저는 동시성 문제가 있으므로 공유하면 안됨

* 영속성 컨텍스트(persistence context) : 엔티티를 영구 저장하는 환경, 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
* 엔티티 생명주기
  1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
  2. 영속 : 영속성 컨텍스트에 저장된 상태
  3. 준영속 : 영속성  컨텍스트에 저장되었다가 분리된 상태
  4. 삭제: 삭제된 상태
 
* 영속성 컨텍스트의 특징
  1. 영속 상태는 반드시 식별자 값을 갖음
  2. 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 db에 반영(플러시)
  3. 장점들
      - 1차 캐시 : 영속성 컨텍스트에 내부에 map을 가지고있음, 키는 식별자, 값은 엔티티 인스턴스, 모두 이곳에 저장
      - 동일성 보장
      - 트랜잭션을 지원하는 쓰기 지연: 내부에 쓰기 지연 SQL 저장소를 가지고 있어 일단 여기에 저장, 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문, 커밋직전에만 반경 내용을 데이터베이스에 보내 동기화하면 됨
      - 변경 감지 : 최초 상태를 복사해서 저장함(스냅샷), 플러시 시점에 스냅샷과 엔티티를 비교하여 수정 쿼리를 생성 후 쓰기 지연 SQL 저장소에 보냄, 성능상의 이유로 모든 필드를 업데이트 (모든 필드를 사용하면 수정 쿼리가 항상 같아서 미리 생성해두고 재사용)
      - 지연 로딩
    
* 플러시 방법
  1. em.flush() 직접호출
  2. 트랜잭션 커밋 시
  3. JPQL 쿼리 실행 시

* @Entity 적용 시 주의사항
  - 기본 생성자 필수 : JPA가 객체를 생성할  때 기본생성자를 사용
  - final 클래스, enum, interface, inner 클래스에는 사용할 수 없음
  - 저장할 필드에 final을 사용하면 안됨
 
* 기본 키 매핑
  - 직접 할당 : 기본 키를 애플리케이션에서 직접 할당
  - 자동 생성 : 대리 키 사용 방식
      - IDENTITY: 기본 키 생성을 데이터베이스에 위임
      - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당
      - TABLE: 키 생성 테이블을 사용
      - 오라클은 시퀀스를 제공, mysql은 제공 X, 대신 AUTO_INCREMENT를 제공, SEQUENCE나 IDENTITY 전략은 사용하는 db에 의존, 테이블 전략은 모든 db에서 사용가능
   
* IDENTITY 전략
  - 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
  - db에 값을 저장하고 나서 기본 키값을 구할 수 있을 때 사용
  - 데이터를 저장하면서 동시에 생성된 키값을 얻어올수있게 최적화 (Statement.getGenereatedKeys() 호출), db와 한번만 통신
  - em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달 -> 쓰기 지연 동작하지 않음
 
* SEQUENCE 전략
  - 데이터베이스 시퀀스 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트
  - 시퀀스를 지원하는 오라클, PostgreSQL, DB2, H2 데이터베이스 사용할 수 있음
  - 시퀀스를 만들고 엔티티와 매핑
  - em.persist()를 호출할 때 db 시퀀스를 사용해서 식별자를 조회 후 엔티티에 할당, 트랜잭션 커밋일어날 때 플러시, IDENTITY와 반대
  - allocationSize 만큼 시퀀스값을 증가시킴, 최적화를 위해, 값을 선점해서 여러 JVM에서 충돌하지 않음, 한 번에 많이 증가하는점을 염두해두어야함, 이런상황이 부담스러우면 allocationSize를 1로
 
* TABLE 전략
  - 키 생성 전용 테이블을 하나 만들어서 사용, 시퀀스를 흉내내는 전략, 모든 db에 적용 가능
  - select 쿼리 후 다음 값 증가사키기 위해 update도 사용, 시퀀스 전략과 비교하여 db와 통신 한번더함, 최적화 하려면 allcoationSize를 사용
 
* AUTO 전략
  - 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택
 
* 자연 키 : 비즈니스에 의미가 있는 키(주민등록번호, 이메일, 전화번호)
* 대리 키 : 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키(오라클 시퀀스, auto_increment, 키생성 테이블 사용)

* 컬럼에 int data1은 null 값이 들어갈 수 없기에 자동으로 not null, 그러나 Integer data1은 null이 들어갈수있어서 not null이 추가되지않음
* @Column을 사용하면 int data1에도 not null이 추가되지않음 따라서 안전하게 nullable = false로 지정하는 것이 안전함

* 양방향 연관관계
  - 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 둘 사이에 차이가 발생 -> 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인 이라함
  - 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야함
  - 연관관계의 주인만이 외래 키의 값을 변경할 수 있음
  - 연관관계 편의 메소드를 이용하여 양 객체 정합성 맞추기
 
* 일대다 단방향 매핑의 단점
  - 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있음, 본인테이블에 있으면 insert 쿼리한방, 아니면 update sql 추가 실행
  - 다대일 매핑관계 권장
 
* 일대일
  - 주 테이블에 외래 키 : 외래 키를 객체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호, 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있음
  - 대상 테이블에 외래 키 : 전통적인 데이터베이스 개발자들은 보통 대상 테이블에 외래키를 두는것을 선호, 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있음
  - 주 테이블에 외래 키는 단방향, 양방향가능
  - 대상 테이블에 외래 키는 단방향 불가능, 양방향 가능
 
* 다대다
  - @ManyToMany로 단순하게 연결테이블을 통하여 pk,fk만 가지고는 한계, 연결 엔티티 사용하기
 
* 복합 기본 키
  - 기본 키가 여러개의 id로 이루어진 복합 기본 키
  - @IdClass를 사용해서 식별자 클래스를 지정
  - @EbeddedId를 사용하는 방법도 있음
  - 복합키 쓰기 어려움, 그냥 대리키 사용
 
* 상속 관계 매핑
  - 조인전략 : 각각의 테이블로 변환, 조회할 때 조인 사용
    - 장점 : 테이블이 정규화, 외래 키 참조 무결성 제약 조건을 활용, 저장공간을 효율적사용
    - 단점 : 조회할 때 조인이 많아서 성능 저하, 조회 쿼리 복잡, 데이터를 등록할 insert sql을 두 번 실행
   
  - 단일 테이블 전략 : 테이블을 하나만, 구분 컬럼으로 DTYPE으로 어떤 자식 데이터가 저장되었는지 구분
     - 장점 : 조인필요없어서 성능 좋음, 조회 쿼리 단순
     - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야함, 모든것을 저장하므로 테이블이 커질수있어서 조회성능이 오히려 느려질수 있음
   
  - 구현 클래스마다 테이블 전략 : 자식 엔티티마다 테이블을 만듬, 추천하지 않음
     - 장점 : 서브 타입을 구분해서 처리할 때 효과적, not null 제약 조건 사용할수 있음
     - 단점 : 여러 자식 테이블 함께 조회할 때 성능이 느림, 자식 테이블을 통합해서  쿼리하기 어려움

* @MappedSuperclass : 자식 클래스에게 매핑 정보만 제공하고 싶을 때 사용
  - @MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용할 수 없음
  - 직접 생성해서 사용할 일이 없으므로 추상 클래스로 만드는것 권장

* 식별 관계 : 부모 테이블의 기본 키를 내려 받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계 (여기서 말하는 부모테이블은 객체의 상속과 무관, 단지 테이블의 키를 내려받는 것)
  - 식별 관계 장점은 기본 키 인덱스를 활용하기 좋고, 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있음
* 비식별 관계 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계
  - 필수적 비식별 관계 : 외래키 null 허용하지 않음
  - 선택적 비식별 관계 : 외래키에 null을 허용
  - 비식별 관계 장점은 복잡하지 않고 단순함, 식별관계의 자연 키 컬럼들이 자식에 손자까지 전파되면 변경 힘듬
  - 일반적으로 비식별 관계를 사용
 
* 복합 키 @IdClass, @EmbeddedId
  - equals와 hashCode 필수 구현
  - @EmbeddedId가 더 객체지향적이고 중복도 없음, 근데 jpql에서 길어질 수 있음

* 프록시의 주요 특징
  - 처음 사용할 때 한 번만 초기화
  - 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것이 아님, 단지 실제 엔티티에 접근할 수 있음
  - 준영속 상태의 프록시를 초기화하면 문제가 발생함 (LazyInitializationException 예외 발생)
 
* @JoinColumn(name = "TEAM_ID", nullable = false)
  - NULL 값을 허용하지 않는다고 알려주면 JPA는 외부 조인 대신에 내부 조인을 사용

* 컬렉션에 EAGER 사용 시 주의점
  - 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
  - 컬렉션 즉시 로딩은 항상 외부 조인을 사용
 
* JPA 데이터 타입
  - 기본값 타입
    - 자바 기본 타입(int, double)
    - 래퍼 클래스(Integer)
    - String
  - 임베디드 타입(복합 값 타입)
  - 컬렉션 타입
 
* 임베디드 타입
   - 응집력 있게 표현 가능 ( 시, 군 , 우편번호 -> Address 타입으로)
   - 식별자가 없기때문에 추적 불가
   - 한 엔티티에 같은 임베디드 타입이 있을경우 @AttributeOverrides 사용
   - 값 타입을 공유하면 안됨, 넘길거면 복사해서
   - 객체의 공유 참조는 피할 수 없음, 미리 예방이 안됨, 대신 불변객체로 만들어 값이 공유 되어도 수정을 막음(Address Setter 막기)
 
* 값 타입 컬렉션의 제약사항
  - 값 타입 컬렉션에 변경 사항이 발생하면, 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고, 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스에 다시저장
  - 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신에 일대다 관계를 고려
  - 기본키가 모든 컬럼임, 따라서 null을 입력할 수 없고 ,같은 값을 중복해서 저장할 수 없음
 
* 엔티티 타입
  - 식별자가 있고 식별자로 구분
  - 생명 주기가 있음, 생성, 영속화, 제거
  - 공유할 수 있음, 참조 값을 공유할 수 있음(공유참조)
 
* 값 타입
  - 식별자가 없음
  - 생명 주기를 엔티티에 의존
  - 공유하지 않는 것이 안전

* 객체지향 쿼리
  - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
  - SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음

* Criteria나 QueryDSL은 JPQL을 편하게 작성하도록 도와주는 빌더 클래스

* Criteria
  - 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있음
  - 컴파일 시점에 오류 발견
  - IDE를 사용하면 코드 자동완성을 지원
  - 동적 쿼리를 작성하기 편함
  - 메타모델을 사용하면 아예 문자열을 없앨수 있음, m.get("username) -> m.get(Member_.username)
  - 단점은 복잡하고 장황
 
* QueryDSL
  - criteria보다 QueryDSL이 단순하고 사용하기 쉬움
  - QueryDSL도 어노테이션 프로세스 기능을 사용하여 어노테이션을 분석해서 쿼리 전용 클래스를 생성(Qmember)

 * 임베디드 타입은 엔티티 타입이 아닌 값 타입, 따라서 이렇게 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않음

* SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라함, 대상은 엔티티, 임베디드 타입, 스칼라 타입(숫자,문자 기본데이터 타입)

* 일대다 조인은 결과가 증가할 수 있지만 일대일, 다대일 조인은 결과가 증가하지 않는다.
  - 팀A의 members를 fetch join 하면 members의 크기만큼 쿼리 결과 나옴
  - 1 팀A 회원1,  2 팀A 회원2 -> 쿼리결과 두개의 로우, 객체입장에서는 팀A가 중복, 쿼리의 distinct 입력 시 제거 안됨 -> 두 개의 row가 다르기때문
  - JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하고 애플리케이션에서 한 번 더 중복을 제거함
 
* 글로벌 로딩전략은 엔티티에 직접 적용하는 로딩 전략(@OneToMany(fetch - FetchTpe.LAZY)
  - 즉시 로딩으로 설정하면 항상 즉시 로딩, 전체로 보면 오히려 성능에 악영향, 지연로딩하고 최적화 필요시 fetch join

* 페치 조인 한계
  - 페치 조인 대상에는 별칭을 줄 수 없음
  - 둘 이상의 컬렉션을 페치할 수 없음(구현체 따라 되기도 하는데 컬렉션*컬렉션의 카테시안 곱이 만들어지므로 주의)
  - 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없음
    - 페치 조인하면 경고 로그를 남기면서 메모리에서 페이징 처리
    - batch size 사용, 다대일로 fetch join
   
* 경로 표현식
 - 상태 필드 : 단순히 값을 저장하기 위한 필드
   - 경로 탐색의 끝, 더는 탐색 X
 - 연관 필드 : 연관관계를 위한 필드(단일 값 연관필드 - ManyToOne, OneToOne, 컬렉션 값 연관 필드 - OneToMany, ManyToMany)
   - 단일 값 연관 경로: 묵시적으로 내부 조인, 계속 탐색 가능 ( select o.member from Order o)
   - 컬렉션 값 연관 경로: 묵시적으로 내부 조인, 더는 탐색 할 수 없음, 단 별칭을 얻으면 별칭을 탐색
      - select t.members from Team t // 성공
      - select t.members.username from Team t // 실패
      - select m.username from Team t join t.members m // 성공
    
   - size를 사용하면  COUNT 함수를 사용하는 SQL로 적절히 변환
   - 묵시적조인은 하눈에 파악하기 어려움, 명시적 조인을 사용
  

* 서브 쿼리
  - JPQL은 서브쿼리를 WHERE, HAVING 절에서만 사용할 수 있고 SELECT, FROM 절에서는 사용할 수 없음
 
* 한 번에 여러 데이터를 수정할 수 있는 벌크 연산
  - 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리, 따라서 벌크 연산먼저 실행하는게 유용
 
* JPQL로 조회했는데 이미 영속성 컨텍스트에 있을 경우 버림

* @PersistenceContext : EntityManager 주입
* @PersistenceUnit : EntityManagerFactory 주입

* 

  
