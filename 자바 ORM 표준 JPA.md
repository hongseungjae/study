* SQL매퍼 문제점
1. CRUD 코드의 반복
2. SQL의 의존적
    - 멤버 엔티티에 컬럼이 추가될경우 sql도 수정해야됨
    - 멤버 엔티티에 팀 엔티티를 추가할 경우 sql도 수정해야 null을 방지할 수 있음

3. 객체 구조를 테이블 구조에 저장하는 데는 한계가 있음 -> 패러다임 불일치
    - 상속
    - 참조 vs 외래키
    - 그래프탐색 자유로이 할 수 있는가 -> JPA는 지연로딩을 통해 해결
    - 비교 같은 로우를 select를 했을 때 == 동일성 비교를하면 false가 나옴 객체이기때문에 -> JPA는 같은 트랜잭션일 때 같은 객체 보장

* JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준
* ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑한다는 뜻, ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해

* JPA 장점
  1. 생산성
  2. 유지보수
  3. 패러다임의 불일치 해결
  4. 성능 : 같은 트랜잭션에 두 번 조회하면 한번만 db에 접근
  5. 데이터 접근 추상화와 벤더독립성 : 예를 들어 JPA Dialect를 사용하기때문에 각 db마다 dialect를 바꿔서 넣어주면됨
 
* 엔티티 매니저 팩토리는 엔티티 매니저를 제공해줌, 만드는 비용이 크기때문에 한 개만 만들어서 애플리케이션 전체에 공유, 여러 스레드가 동시에 접근해도 안전함
* 엔티티 매니저는 동시성 문제가 있으므로 공유하면 안됨

* 영속성 컨텍스트(persistence context) : 엔티티를 영구 저장하는 환경, 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
* 엔티티 생명주기
  1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
  2. 영속 : 영속성 컨텍스트에 저장된 상태
  3. 준영속 : 영속성  컨텍스트에 저장되었다가 분리된 상태
  4. 삭제: 삭제된 상태
 
* 영속성 컨텍스트의 특징
  1. 영속 상태는 반드시 식별자 값을 갖음
  2. 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 db에 반영(플러시)
  3. 장점들
      - 1차 캐시 : 영속성 컨텍스트에 내부에 map을 가지고있음, 키는 식별자, 값은 엔티티 인스턴스, 모두 이곳에 저장
      - 동일성 보장
      - 트랜잭션을 지원하는 쓰기 지연: 내부에 쓰기 지연 SQL 저장소를 가지고 있어 일단 여기에 저장, 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문, 커밋직전에만 반경 내용을 데이터베이스에 보내 동기화하면 됨
      - 변경 감지 : 최초 상태를 복사해서 저장함(스냅샷), 플러시 시점에 스냅샷과 엔티티를 비교하여 수정 쿼리를 생성 후 쓰기 지연 SQL 저장소에 보냄, 성능상의 이유로 모든 필드를 업데이트 (모든 필드를 사용하면 수정 쿼리가 항상 같아서 미리 생성해두고 재사용)
      - 지연 로딩
    
* 플러시 방법
  1. em.flush() 직접호출
  2. 트랜잭션 커밋 시
  3. JPQL 쿼리 실행 시

* @Entity 적용 시 주의사항
  - 기본 생성자 필수 : JPA가 객체를 생성할  때 기본생성자를 사용
  - final 클래스, enum, interface, inner 클래스에는 사용할 수 없음
  - 저장할 필드에 final을 사용하면 안됨
 
* 기본 키 매핑
  - 직접 할당 : 기본 키를 애플리케이션에서 직접 할당
  - 자동 생성 : 대리 키 사용 방식
      - IDENTITY: 기본 키 생성을 데이터베이스에 위임
      - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당
      - TABLE: 키 생성 테이블을 사용
      - 오라클은 시퀀스를 제공, mysql은 제공 X, 대신 AUTO_INCREMENT를 제공, SEQUENCE나 IDENTITY 전략은 사용하는 db에 의존, 테이블 전략은 모든 db에서 사용가능
   
* IDENTITY 전략
  - 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
  - db에 값을 저장하고 나서 기본 키값을 구할 수 있을 때 사용
  - 데이터를 저장하면서 동시에 생성된 키값을 얻어올수있게 최적화 (Statement.getGenereatedKeys() 호출), db와 한번만 통신
  - em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달 -> 쓰기 지연 동작하지 않음
 
* SEQUENCE 전략
  - 데이터베이스 시퀀스 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트
  - 시퀀스를 지원하는 오라클, PostgreSQL, DB2, H2 데이터베이스 사용할 수 있음
  - 시퀀스를 만들고 엔티티와 매핑
  - em.persist()를 호출할 때 db 시퀀스를 사용해서 식별자를 조회 후 엔티티에 할당, 트랜잭션 커밋일어날 때 플러시, IDENTITY와 반대
  - allocationSize 만큼 시퀀스값을 증가시킴, 최적화를 위해, 값을 선점해서 여러 JVM에서 충돌하지 않음, 한 번에 많이 증가하는점을 염두해두어야함, 이런상황이 부담스러우면 allocationSize를 1로
 
* TABLE 전략
  - 키 생성 전용 테이블을 하나 만들어서 사용, 시퀀스를 흉내내는 전략, 모든 db에 적용 가능
  - select 쿼리 후 다음 값 증가사키기 위해 update도 사용, 시퀀스 전략과 비교하여 db와 통신 한번더함, 최적화 하려면 allcoationSize를 사용
 
* AUTO 전략
  - 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택
 
* 자연 키 : 비즈니스에 의미가 있는 키(주민등록번호, 이메일, 전화번호)
* 대리 키 : 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키(오라클 시퀀스, auto_increment, 키생성 테이블 사용)

* 컬럼에 int data1은 null 값이 들어갈 수 없기에 자동으로 not null, 그러나 Integer data1은 null이 들어갈수있어서 not null이 추가되지않음
* @Column을 사용하면 int data1에도 not null이 추가되지않음 따라서 안전하게 nullable = false로 지정하는 것이 안전함

* 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 둘 사이에 차이가 발생 -> 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인 이라함
* 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야함
* 연관관계의 주인만이 외래 키의 값을 변경할 수 있음
* 연관관계 편의 메소드를 이용하여 양 객체 정합성 맞추기

* 

