### 1,2장 운영체제 개요

운영체제(operating system)란 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어

사용자 입장에서 하드웨어 자체를 다루는게 어려움 -> 하드웨어 위에 기본적으로 운영체제를 탑재해 손쉽게 사용할 수 있는 상태가 되도록함

운영체제도 하나의 소프트웨어로 전원이 켜지면 동시에 메모리에 올라감, 메모리에 상주하는 운영체제의 부분을 커널이라고함

운영체제는 편리한 인터페이스를 제공 (예를 들어 파일이 디스크에 어떻게 저장되는지 자세히 알지못하지만, 쉽게 저장하거나 꺼내쓸수있음)

운영체제는 컴퓨터 시스템 내의 자원(CPU, 메모리, 하드디스크 등 소프트웨어 자원도 포함)을 효율적으로 관리

시분할시스템 - CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템, cpu가 1개일때
다중 프로그래밍 시스템 - CPU와 달리 메모리의 경우 동시에 프로그램이 올라갈수있어서 이렇게 처리하는 시스템


메모리


고정분할방식 -> 내부단편화 - 공간이 작아 메모리할당안됨


가변분할방식 -> 외부단편화 - 작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우

가상메모리방식(일반적) -> 사용되고있는 부분만 메모리, 나머지는 하드디스크와 같은 보조기억장치로(스왑영역)


인터럽트 : 주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데, 이때 발생시키는 신호

### 3장 컴퓨터 시스템의 동작 원리

각 하드웨어 장치마다 컨트롤러라는 이들을 제어하는 작은 CPU가 있음(메모리 컨트롤러, 디스크 컨트롤러 등)

컨트롤러는 작은 메모리를 가지고있음(로컬버퍼, 데이터를 임시 저장)

프로그램 B가 디스크에서 데이터를 읽어오라는 명령을 내리면, 디스크 컨트롤러가 디스크에서 내용을 읽어 로컬버퍼에 저장, 메인 CPU에게 인터럽트를 발생시켜 다음 일을 수행

인터럽트는 키보드 입력 혹은 요청된 디스크 입출력 작업의 완료 등 CPU에 알려줄 필요가 있는 이벤트가 일어난 경우 컨트롤러가 발생시키는 것

하드웨어 인터럽트와 소프트웨어 인터럽트(트랩)

소프트웨어 인터럽트의 예로는 예외상황(exception)과 시스템 콜(system call)이 있음


예외상황은 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도해 자신의 메모리 영역 바깥에 접근시도하는 등 권한이 없는 작업을 시도할 때 처리하기위해

시스템콜은 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하기위해(예를 들어 화면 출력 등), 이미 존재하는 커널의 코드를 호출해서 처리

모두 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양됨

운영체제가 직접 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않음

프로그램이 동시에 입출력 연산을 요청하는 경우 동기성을 보장하기 위해 장치마다 디바이스큐를 두어 요청된 순서대로 처리할수도 있도록 함

프로그램 A가 실행중에 디스크에서 어떤 데이터를 읽어오는 명령을 만나면
프로그램 A 시스템콜 -> CPU는 현재의 상태 저장 후 인터럽트에 의해 처리해야할 커널의 루틴을 이동 -> CPU는 컨트롤러에게 입출력 연산 요청 -> 컨트롤러는 데이터를 디스크로부터 자신의 로컬버퍼로 읽어옴 -> 운영체제는 프로그램 A가 입출력 연산중이므로 CPU를 할당해도 명령을 수행하지못하므로 봉쇄표시 -> 다른 프로그램에게 CPU할당 -> 원하는 정보가 로컬버퍼로 다 읽어오면 하드웨어 인터럽트 발생 -> 다시 CPU가 인터럽트 처리 ( 요청한 데이터를 A의 메모리 영역으로 읽어옴) -> 프로그램 A 봉쇄 해제

DMA (Direct Memmory Access) : 메모리는 CPU에 의해서만 접근 가능, 그러니 컨트롤러들이 인터럽트를 발생시켜 CPU에게 로컬버퍼와 메모리 사이에 데이터를 옮겨달라고 부탁

그러나 인터럽트 자주 발생하면 효율이 떨어질 수 있음 따라서 DMA가 대신 로컬버퍼에서 데이터를 읽어오느 작업 대행

저장장치
주기억장치 : 메모리, 휘발성
보조기억장치 : 두가지기능, 파일시스템용, 스왑영역(메모리 연장공간)

캐싱기법 : 용량이 적은 빠른 저장장치를 이용해 느린 저장치의 성능을 향상시키는 총제적 기법

다중 프로그래밍 환경에서 동작, 프로그램끼리 충돌을 일으키는 문제를 막기 위해 하드웨어적인 보안을 유지하기 위해 커널모드와 사용자 모드를 지원
커널모드 : 운영체제가 CPU의 제어권을 가지고 운영체제 코드르 실행하는 모드

사용자 프로그램이 CPU를 가지고 있으면 운영체제에서 제어 방법이 없음 -> 하드웨어적인 방법으로 CPU에 모드 비트를 줌(0 - 커널, 1 - 사용자) -> 운영체제가 CPU의 제어권을 넘길때 1

하나의프로그램이 계속적으로 CPU 차지 막기위해 -> 타이머라는 하드웨어 인터럽트 사용

### 4장 프로그램의 구조와 

프로그램의 주소 영역
코드 : 프로그램 함수들의 코드가 기계어 형태로 변환되어 저장되는 부분
데이터 : 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분
스택 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시 저장하는 공간

CPU가 수행해야할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터(Program Counter: PC)라고 함

커널의 코드는 : 시스템 콜, 인터럽트 처리코드, 편리한 서비스제공을 위한 코드
커널의 데이터 영역에 모든 자원을 관리하기위한 자료구조를 각각 유지(예 PCB)
커널의 스택은 : 프로세스 A의 커널 스택, B의 커널 스택

프로세스 A가 CPU에서 실행된다는 것은 두가지 -> 사용자 모드에서 실행 상태, 커널모드에서의 실행상태
시스템콜을 통해 실행되는 것이 프로세스 A의 코드가 아닌 운영체제 커널의 코드이지만 커널이 실행 상태라고 말하지 않고 프로세스 A가 실행 상태에 있다고 말함(프로세스 A가 커널모드에서 실행중)

### 5장 프로세스 관리
프로세스의 문맥 : 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보
문맥교환(context switch) : 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정 (예: 타이머 인터럽트, 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우 등)
프로세스의 상태 : 실행, 준비 , 봉쇄(blocked, wait, sleep)의 세 가지중 하나만 머물러 있음

프로세스 제어블록(Process Control Block: PCB)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 

중기 스케줄러 : 장기 스케줄러와 마찬가지로 메모리에 올라와있는 프로세스의 수를 조절 ( 스왑 아웃)
중기스케줄러로 인해 프로세스 상태 추가 - 중지(suspended, stopped) -> 외부에서 재개시키지 않는 이상 다시 활성화 될 수 없음 -> 스왑 아웃 대상

fork를 통해 프로세스 복제 (프로세스 ID를 제외한 모든 정보 -> 주소정보 등)한다.

자식프로세스는 exec 시스템콜을 통해 새로운 프로그램으로 주소 공간을덮어씌움

wait는 자식 프로세스가 죽을때까지 부모 프로세스를 봉쇄상태로

프로세스 간의 협력 매커니즘을 위해 운영체제가 제공하는 대표적인 매커니즘으로 IPC(Inter-Process Communication) -> 의사소통 기능과 함께 동기화를 보장해주어야 함

공유데이터를 서로 다른 두 프로세스가 접근해서 데이터의 불일치가 발생할 수도 있음 -> 막기위한 매커니즘 -> 메시지전달 방식과 공유메모리 방식

메시지 전달방식 : 공유데이터를 사용하지 안하고 메시지를 주고 받으면 통신 -> 커널에 의해 send와 receive
공유메모리 방식 : 프로세스들이 주소 공간의 일부를 공유, 공유메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 매핑되게함 -> 동기화문제를 책임져야함

### 6장 CPU 스케줄링

CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치

사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복
CPU 버스트 : 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 과정
I/O 버스트 : I/O요청이 발생해 커널에 의해 입출력 작업을 진행하는 느린 단계

I/O 바운드 프로세스 : I/O요청이 빈번해 CPU버스트가 짧게 나타나는 프로세스
CPU 바운드 프로세스 : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스

위의 처럼 CPU 버스트가 다 다르기 때문에 적절히 스케줄링해주어야함

선점형 : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링(예 할당시간을 부여한 후 타이머 인터럽트 발생 시킴)
비선점형 : 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않음

디스패처 : 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드 

디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간 이라고함 -> 지연시간의 대부분은 문맥교환 오버헤드

