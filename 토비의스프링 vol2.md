
* 스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립된 컨테이너가 담당 -> IOC컨테이너 (오브젝트에 대한 제어권을 갖고있음)
* 빈 팩토리 : 오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점
* 애플리케이션 컨텍스트 : 빈 팩토리에 여러 가지 컨테이너 기능을 추가한 것
* POJO + 설정 메타정보로 하나의 애플리케이션을 구성 -> 스프링 컨테이너 역할
* 
* IoC 컨테이너의 역할은 초기에 빈 오브젝트를 생성하고 DI 하 후에 최초 애플리케이션을 기동할 빈 하나를 제공해주는 것
  - 자바 프로그램은 main() 메소드를 가진 클래스 시작시켜달라고 요청
  - 하지만 우베에서는 main() 메소드를 호출할 방법이 없으며, 사용자도 여럿이고 동시에 웹 애플리케이션을 사용
  - 서블릿이 일종의 main() 역할을 실행
  - 요청이 서블릿으로 들어올 때마다 getBean()으로 필요한 빈을 가져와 정해진 메소드 실

* 스프링은 프론트 컨트롤러 패턴을 사용 : 몇 개의 서블릿이 중앙집중식으로 모든 요청을 다 받아서 처리하는 방식

* 서블릿 한개당 애플리케이션 컨텍스트가 구성되고, 웹 애플리케이션에 루트 애플리케이션 컨텍스트를 부모를 두고있음 -> 계층 구조 유지이유는 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위해

* 스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 DispatcherServlet, 서블릿이 초기화 될 때 자신만의 컨텍스트 생성하고 초기화, 루트 애플리케이션 컨텍스를 찾아서 자신의 부모 컨텍스트로 사용

* @Componet 지정하면 빈 등록이 가능, @Component를 포함해 디폴트 피털에 적용되는 애노테이션을 스테레오타입 애노테이션이라고함

* 빈 스캐너 단점 : 애플리케이션에서 등록될 빈이 어떤 것들이 있고, 어떻게 정의되는지 한눈에 파악 할 수 없음, XML처럼 상세한 메타정보 항목을 지정 안됨, 클래스당 한 개 이상의 빈을 등록못함

* 디폴트로 정의돈 빈은 싱글톤임, 따라서 return new annotatedHello()를 실행해도 새 객체가 아닌 빈 오브젝트가 반복적으로 리턴, @Bean이 붙은 메소드를 조작

* XML보다 자바코드 이점
  1. 컴파일러나 IDE를 통한 타입 검증 가능, XML은 텍스트문서
  2. 자동완성 기능 최대한 이용
  3. 이해하기 쉬움
  4. 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용

* 멀티 컨텍스트에서 중복 빈 스캐닝으로 문제가 발생할 수 있음(서블릿 컨텍스트와 루트 컨텍스트에 두 개 다 빈이 등록되어 서블릿 컨텍스트에 트랜잭션 aop가 적용이 안된문제)

* 자동와이어링, byName, byType, 타입에 의한 방식은 빈의 이름이나 프로퍼티 이름에 신경을쓰지 않아도 돼서 편리함, 대신 타입이 같은 빈이 두 개 이상 존재하는 경우 적용안됨

* 필드 주입은 테스트 코드 작성하기가 불편함, 왜냐하면 컨테이너가 주입해줘야하기 때문, 그러나 dao처럼 컨테이너 통합테스트일 경우는 고려해볼만함
* 수정자 주입은 외부에서 주입이 가능하다, 그러나 초기화 중 잊어버릴 수 있음, 또 수정자 메소드가 많아질 수 있음
* 생성자 주입은 null이 들어갈 위험이 없다. final을 이용해서, 그러나 모든 프로퍼티를 다 di하게 강제함, 유연성이 떨어질 수 있음

* @Resource 자동 주입 방법은 xml 자동주입과 다르게 빈을 못찾으면 예외 발생, 디폴트 이름으로 참조할 빈을 찾음 -> 타입을 이용해 한 번 더, 이름을 이용한 프로퍼티 설정
  - 수정자, 필드 주입

* @Autowired 스프링 전용 애토테이션, @Injext는 JavaEE 6의 표준 스펙에 정의되어있는 것
  - 생성자, 필드, 수정자, 일반 메소드로 네 가지로 확장
  - @Resource와 다르게 이름 대신 필드나 프로퍼티 타입을 이용해 후보 빈을 찾음
