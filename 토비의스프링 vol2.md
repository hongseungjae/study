* 스프링은 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 코드가 아닌 독립된 컨테이너가 담당 -> 컨테이너가 오브젝트의 대한 제어권을 갖고있음 -> IoC 컨테이너
* 오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점 -> 빈 팩토리
* 빈 팩토리에 여러 가지 컨테이너 기능을 추가한 것 -> 애플리케이션 컨텍스트
* 애플리케이션 컨텍스는 BeanDefintion으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI작업을 수행 -> 메타정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지않음
* IoC컨테이너는 POJO 클래스와 설정 메타정보를 결햅해서 하나의 애플리케이션을 만듬
 
* IoC 컨테이너의 역할은 초기에 빈 오브젝트를 생성하고 DI 한 후에 최초 애플리케이션을 기동할 빈 하나를 제공해주는 것
  - 자바 프로그램은 main() 메소드를 가진 클래스 시작시켜달라고 요청
  - 하지만 웹에서는 main() 메소드를 호출할 방법이 없으며, 사용자도 여럿이고 동시에 웹 애플리케이션을 사용
  - 서블릿이 일종의 main() 역할을 실행
  - 요청이 서블릿으로 들어올 때마다 getBean()으로 필요한 빈을 가져와 정해진 메소드 실

* 스프링은 프론트 컨트롤러 패턴을 사용 : 몇 개의 서블릿이 중앙집중식으로 모든 요청을 다 받아서 처리하는 방식

* 서블릿 한개당 애플리케이션 컨텍스트가 구성되고, 웹 애플리케이션에 루트 애플리케이션 컨텍스트를 부모를 두고있음 -> 계층 구조 유지이유는 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위해

* 스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 DispatcherServlet, 서블릿이 초기화 될 때 자신만의 컨텍스트 생성하고 초기화, 루트 애플리케이션 컨텍스를 찾아서 자신의 부모 컨텍스트로 사용

* @Componet 지정하면 빈 등록이 가능, @Component를 포함해 디폴트 피털에 적용되는 애노테이션을 스테레오타입 애노테이션이라고함

* 빈 스캐너 단점 : 애플리케이션에서 등록될 빈이 어떤 것들이 있고, 어떻게 정의되는지 한눈에 파악 할 수 없음, XML처럼 상세한 메타정보 항목을 지정 안됨, 클래스당 한 개 이상의 빈을 등록못함

* 디폴트로 정의돈 빈은 싱글톤임, 따라서 return new annotatedHello()를 실행해도 새 객체가 아닌 빈 오브젝트가 반복적으로 리턴, @Bean이 붙은 메소드를 조작

* XML보다 자바코드 이점
  1. 컴파일러나 IDE를 통한 타입 검증 가능, XML은 텍스트문서
  2. 자동완성 기능 최대한 이용
  3. 이해하기 쉬움
  4. 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용

* 멀티 컨텍스트에서 중복 빈 스캐닝으로 문제가 발생할 수 있음(서블릿 컨텍스트와 루트 컨텍스트에 두 개 다 빈이 등록되어 서블릿 컨텍스트에 트랜잭션 aop가 적용이 안된문제)

* 자동와이어링, byName, byType, 타입에 의한 방식은 빈의 이름이나 프로퍼티 이름에 신경을쓰지 않아도 돼서 편리함, 대신 타입이 같은 빈이 두 개 이상 존재하는 경우 적용안됨

* 필드 주입은 테스트 코드 작성하기가 불편함, 왜냐하면 컨테이너가 주입해줘야하기 때문, 그러나 dao처럼 컨테이너 통합테스트일 경우는 고려해볼만함
* 수정자 주입은 외부에서 주입이 가능하다, 그러나 초기화 중 잊어버릴 수 있음, 또 수정자 메소드가 많아질 수 있음
* 생성자 주입은 null이 들어갈 위험이 없다. final을 이용해서, 그러나 모든 프로퍼티를 다 di하게 강제함, 유연성이 떨어질 수 있음

* @Resource 자동 주입 방법은 xml 자동주입과 다르게 빈을 못찾으면 예외 발생, 디폴트 이름으로 참조할 빈을 찾음 -> 타입을 이용해 한 번 더, 이름을 이용한 프로퍼티 설정
  - 수정자, 필드 주입

* @Autowired 스프링 전용 애테이션, @Injext는 JavaEE 6의 표준 스펙에 정의되어있는 것
  - 생성자, 필드, 수정자, 일반 메소드로 네 가지로 확장
  - @Resource와 다르게 이름 대신 필드나 프로퍼티 타입을 이용해 후보 빈을 찾음
  - @Autowired는 타입이 같은 여러빈을 컬렉션이나 배열로 선언하여 다 받을 수 있음
  - @Autowired에서 타입 외의 정보를 추가해서 세밀하게 도움 주는 보조 방법은 @Qualifier를 사용하는것
  - 이름을 매핑할때 -> @Resource,  타입과 한정자 매칭할 때 -> @Autowired, @Qualifier

* @Autowired와 같은 애노테이션을 통한 의존관계 설정은 빈 오브젝트 등록을 마친 후에 후처기에 의해 별도의 작업으로 진행됨

* @Value에 직접 값을 지정하는 방법은 잘사용하지 않음
 - 대신 자바 코드 외부의 리소스나 환경정보에 담긴 값을 사용하도록 지정해줌, @Value("#systemProperties['os.name']}"), @Value("${database.username}")

* 빈 후처리기는 매 빈 오브젝트가 만들어진 직후에 오브젝트의 내용이나 오브젝트 자체를 변경할 때 사용
* 빈 팩토리 후처리기는 빈 설정 메타정보가 모두 준비됐을 때 빈 메타정보 자체를 조작하기 위해 사용(PropertyPlaceHolderconfigurer), 치환자를 찾지 못해도 예외가 발생하지않음




