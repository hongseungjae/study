
### 스프링 소개

* ApplicationContext 인터페이스는 스프링이 관리하는 범위 내에 잇는 모든 환경 정보를 저장하는데 사용됨, ListableBeanFactory라는 인터페이스를 상속해 스프링이 관리하는 모든 빈 인스턴스에 대한 공급자 역할을 함
  - BeanFactory를 상속한 인터페이스
  - DI 서비스 외에도 트랜잭션 서비스, AOP 서비스, 국제화를 위한 메시지 소스, 이벤트 처리와 같은 여러 서비스를 제공

이게 없었다면 직접 프로퍼티를 읽는 코드를 작성해서 클래스를 가져와야함

* IoC는 의존성 주입(DI)과 의존성 룩업(DL : Dependency Lookup)으로 두 가지 하위 분류로 나뉨

* 수정자 주입 : 새로운 객체를 생성하지 않아도 의존성을 교체 가능, 명시적으로 객체를 주입하지 않더라도 적절한 기본 값을 선택 할 수 있게 할 수 있음

* 생성자 주입 : 컴포넌트에 의존성 주입을 보장하거나 불변 객체를 설계하는 경우 좋음

* 필드 주입 : @Autowired로 필드 추입, 의존성을 추가 하기 쉬움, 그러나 의존성이 필수인지 여부가 명확하지 않음, final 필드 사용 불가, 의존성을 수동으로 주입해야 하므로 테스트 코드 작성 어려

* 스테레오타입 애너테이션 : 빈의 역할, 예) @Service, @Repository

* @Component는 구성 관련 , @Service는 비즈니스 서비스 제공 목적, 둘 다 자동 검출과 클래스 경로 스캐닝의 대상

* 메서드주입은, 싱글톤빈에서 비싱글톤빈(상태를 저장해야하는)을 가져오기 위해 사용, 호출때마다 새로운 빈, 대상의 스코프를 프로토타입으로 설정하고(@Scope("prototype")), @Lookup 해도됨

* 메서드 대체는 Method Replacer를 이용하여 다른 빈으로 동작하게 바꿀 수 있다.(CGLIB이용)

* 싱글톤 패턴은 애플리케이션 전체에서 클래스의 단일 인스턴스를 유지 관리하고 접근하도록 하는 목표는 달성하지만, 결합도 증가됨 -> 어떻게 싱글턴 클래스의 인스턴스를 얻어야하는지 잘알고있어야됨, 즉 인터페이스를 사용한 코딩이 불가능, 싱글턴은 목 클래스로 대체할수 없으므로 단위 테스트 까다로움

* 싱글톤 객체가 맞는 시나리오
  1. 상태가 없는 공유 객체
  2. 읽기 전용 상태를 갖는 공유 객체
  3. 공유 상태를 갖는 공유 객체
  4. 쓰기 가능 상태를 갖는 대용량 처리 객체(쓰기 접근을 동기화해야됨, 수백 개의 인스턴스를 만드는 것보다 나은 성능일 수 있음)

* 비싱글톤 객체 시나리오
  1. 쓰기 가능한 상태를 갖는 객체
  2. private 상태를 갖는 오브젝트(자신만의 처리 작업을 하)

* 자동 주입 시 byType으로, @Primary로 우선순위 가능, 3개 이상일 경우 @Qulifier

* partent 빈 상속을 통해 원하는 값만 하위 빈에 제공 가능

=========================

* 빈의 라이프사이클 이벤트를 받을 수 있는 세 가지 메커니즘 제공
  1. 인터페이스 기반 (InitializingBean 인터페이스 구현하기)
  2. 메서드 기반 (init() 구현, init-method="init" 설정)
  3. 애너테이션 기반 (@PostConstruct 애너테이션 사용)

* default-lazy-init="true" 는 스프링이 처음부터 모든 빈을 초기화 하지 않고 애플리케이셔니 스프링에게 빈을 요청할 때만 해당 빈을 초기화, or @Lazy

* 빈의 초기화 콜백은 의존성을 검사하고 적절한 초기값을 제공하려는 목적으로 사용할 때 가장 유용

* 자신에게 부여된 빈 이름 알기 - BeanNameAware 인터페이스 구현하기

* 빈에서 getBean으로 가져오려면 -  ApplicationContextAware 인터페이스 구현하기

* 스프링을 사용해 어떤 객체를 관리하려면 - 예를 들어 MessageDigest 객체 생성을 관리하려면 FactoryBean을 사용하면 좋음
  - MessageDigest는 MD5, SHA1 등 여러가지로 빈이 될 수 있음, 그럼 다 등록해야됨?, 팩토리빈을 만들고 그 빈에서 MessageDigest를 반환하게하면됨
  - FactoryBean은 new 연산자로 인스턴스를 생성할 수 없는 클래스를 다룰 때 완벽한 솔루션이다.

* @PropertySource로 외부 프로퍼티를 읽어 값을 주입할 수 있음

* @Import를 통해 해당 구성 클래스에 정의된 빈에 접근할 수 있음

* @ImportResource 는 xml에 정의된 빈을 읽을 때

* @Profile을 이용해 필요한 빈만 인스턴스 생성할수있게 할 수 있음(-Dspring.profiles.active 값 전달)
  - Test시 @ActiveProfiles로 활성화 가능

* @Autowired required(DI가 반드시 제공돼야하는지) 사용가능, JSR-330의 @Inject는 해당 기능 없음, JSR-330은 @Lazy없음

* 컨텍스트에 정의된 모드느 빈 목록 가져오기 : 		ConfigurableApplicationContext run = SpringApplication.run(ChatServiceApplication.class, args);
, Arrays.stream(ctx.getBeanDefinitionsNames()).forEach(logger::info);

* @SprinbBootApplication 최상위 애너테이션
  - @Configuration : 빈을 정의하는 구성 클래스
  - @EnableAutoConfiguration : 스프링부트 애너테이션으로 제공된 의존성을 기반으로 사용자가 필요로 할 빈을 추측해 구성한 뒤 스프링 ApplicationContext 활성화
  - @ComponentScan : 지정하지 않으면 SpringBootApplication을 붙인 클래스가 위치한 패키지만을 검
